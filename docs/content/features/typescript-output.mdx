---
title: TypeScript Output Format
description: Generate tree-shakable TypeScript code for type-safe route access
---

## üî∑ TypeScript Output Format

The `--format typescript` option generates **tree-shakable** TypeScript code that provides **type-safe route access** using dot notation. Each top-level route is exported as a named export for optimal bundler tree-shaking.

### Generated Structure

```typescript
// Ultra-granular named exports for maximum tree-shaking
export const blog = {
  index: { path: "/blog" },
  posts: {
    byId: { path: "/blog/posts/[id]", get: ({ id }: { id: string }) => `/blog/posts/${id}` },
    bySlugRest: { path: "/blog/posts/[...slug]", get: ({ slug }: string[]) => `/blog/posts/${slug.join('/')}` }
  }
};
export const blog_posts = {
  byId: { path: "/blog/posts/[id]", get: ({ id }: { id: string }) => `/blog/posts/${id}` },
  bySlugRest: { path: "/blog/posts/[...slug]", get: ({ slug }: string[]) => `/blog/posts/${slug.join('/')}` }
};
export const blog_posts_byId = {
  path: "/blog/posts/[id]",
  get: ({ id }: { id: string }) => `/blog/posts/${id}`
};
export const blog_posts_bySlugRest = {
  path: "/blog/posts/[...slug]",
  get: ({ slug }: string[]) => `/blog/posts/${slug.join('/')}`
};
export const settings = { socialAccounts: { path: "/settings/social-accounts" } };
export const settings_socialAccounts = { path: "/settings/social-accounts" };

// Getter-based routes object mirroring the structure (tree-shakable)
export const routes = {
  get blog() {
    return {
  get posts() {
    return {
  get byId() {
    return blog_posts_byId;
  }
    };
  }
    };
  },
  get settings() {
    return {
  get socialAccounts() {
    return settings_socialAccounts;
  }
    };
  }
} as const;

// Default export for convenience
export default routes;
```

### Usage in Your Code

```typescript
// Maximum tree-shaking: import only what you need
import { blog_posts_byId } from './routes';

// Only the specific route is included in your bundle
const postUrl = blog_posts_byId.get({ id: "123" });     // "/blog/posts/123"

// Ultra tree-shakable imports (recommended for minimal bundles)
import { fournisseur_byVendorId } from './routes';       // Only imports this specific route
const url1 = fournisseur_byVendorId({ vendorId: "123" }); // "/fournisseur/123"

// Tree-shakable section imports
import { blog_posts } from './routes';                   // Includes posts.byId
import { blog } from './routes';                         // Includes entire blog tree

// Convenient dot notation (still tree-shakable!)
import { routes } from './routes';
const postUrl = routes.blog.posts.byId({ id: "123" });  // IntelliSense: "URL: /blog/posts/<id>"
const vendorUrl = routes.fournisseur.byVendorId({ vendorId: "abc" }); // IntelliSense: "URL: /fournisseur/<vendorId>"

// Access the path template
const postTemplate = routes.blog.posts.byId.path;       // "/blog/posts/[id]"

// Traditional get method still available (backward compatibility)
const altUrl = routes.blog.posts.byId.get({ id: "123" }); // Same result

// Use with Next.js Link or router.push
<Link href={routes.blog.posts.byId.get({ id: postId })}>
  View Post
</Link>

// TypeScript will infer the correct types automatically
function navigateTo(route: string) {
  // route is typed as a union of all possible route strings
}
```

### Features

- **Type Safety**: Full TypeScript intellisense and compile-time checking through `as const`
- **Dot Notation**: Access routes using familiar JavaScript object notation
- **Consistent API**: All routes have a `path` property for uniform access
- **Parameterized Routes**: Dynamic routes include type-safe getter methods (e.g., `byId.get({ id: "123" })`)
- **Special Character Handling**: Hyphens become camelCase, dots become underscores
- **Route Filtering**: Only includes actual navigable routes (page.tsx files), excludes special Next.js files
- **Catch-All Route Support**: `[...slug]` becomes `bySlugRest`, `[[...slug]]` becomes `bySlugOptional`
- **Auto-completion**: IDEs provide full auto-completion for all routes and parameters
- **No Runtime Overhead**: Pure TypeScript `as const` assertions, zero runtime cost
- **IDE IntelliSense**: JSDoc comments show expected URL patterns (e.g., `URL: /fournisseur/<vendorId>`)
- **Parameter Validation**: Compile-time checking of required route parameters
- **Maintainable**: Automatically stays in sync with your route structure

### Benefits

- **üöÄ Ultra-Granular Tree-Shaking**: Every route exported individually + direct references in routes object
- **üì¶ Minimal Bundle Size**: Direct references enable tree-shaking even with dot notation
- **üöÄ True Tree-Shaking**: Bundlers eliminate unused routes regardless of import style
- **üìû Callable Routes**: Parameterized routes are directly callable: `byId({ id: "123" })`
- **üéØ Maximum Flexibility**: Import at any granularity from individual routes to entire sections
- **üîÑ Backward Compatible**: Existing `.get()` method still works for gradual migration
- **üèóÔ∏è Structural Mirroring**: The `routes` object perfectly mirrors your route hierarchy

### Command Examples

```bash
# Generate TypeScript route definitions
next-introspect introspect . --format typescript --output routes.ts

# Generate with custom namespace
next-introspect introspect . --format typescript --namespace "AppRoutes" --output app-routes.ts

# Combine with other options
next-introspect introspect . --format typescript --mode comprehensive --output routes.ts
```

### Programmatic Generation

```typescript
import { NextIntrospect } from 'next-introspect';

const introspect = new NextIntrospect('./my-app');
await introspect.analyze();

// Generate TypeScript routes
const typescriptCode = introspect.format('typescript');
await introspect.exportToFile('routes.ts', 'typescript');
```

This format is perfect for applications that need type-safe route references throughout the codebase, providing both runtime values and compile-time type checking.
